''' osm_parse.py

Contains code to parse data from standard OSM files (e.g. generated by
geofabrik) and from ATKIS data converted to OSM by ogr2osm.py.

'''
import math
import re
from graph import Graph, Edge, NodeInfo


osm_speed_table = {"motorway"       : 110,
                   "trunk"          : 110,
                   "primary"        : 70, 
                   "secondary"      : 60, 
                   "tertiary"       : 50, 
                   "motorway_link"  : 50, 
                   "trunk_link"     : 50, 
                   "primary_link"   : 50, 
                   "secondary_link" : 50, 
                   "road"           : 40, 
                   "unclassified"   : 40, 
                   "residential"    : 30, 
                   "unsurfaced"     : 30, 
                   "cycleway"       : 25, 
                   "living_street"  : 10, 
                   "bridleway"      : 5,
                   "service"        : 5,
                   "OTHER"          : 0,
                   "track"          : 5,
                   "footway"        : 5,
                   "pedestrian"     : 5,
                   "tertiary_link"  : 5,
                   "path"           : 4,
                   "steps"          : 3}

atkis_speed_table = {164001 : 110, 
                     164003 : 70,
                     164005 : 110,
                     164007 : 70,
                     164009 : 110,
                     164010 : 70,
                      87001 : 50,
                      87003 : 5,
                      87004 : 25,
                      88001 : 25,
                      89001 : 25,
                      89002 : 10,
                      90001 : 110,
                      90003 : 70,
                      90005 : 110,
                      90007 : 70,
                      90009 : 110,
                      90010 : 70,
                      90012 : 50,
                      90014 : 5,
                      90015 : 25,
                      90016 : 25,
                      90017 : 25,
                      90018 : 10}

def type_to_speed(type, speed_table):
  if type in speed_table:
    return speed_table[type]
  else:
    print "type '" + type + "' unknown."
    return 0


def Std_OSM_way_tag_interpreter(key, val):
  ''' Interprets way tags of a standard OSM file. 
  
  Such lines have a format
    <tag k="KEY" v="VAL" />
  We are interested only in ways of KEY=highway and with VAL being one of
  the way types declared in the speed table.

  '''
  if key == 'highway' and val in osm_speed_table:
    return type_to_speed(val, osm_speed_table)
  return False


ATKIS_HIGHWAY_VALUE_RANGE = set(range(164001, 164012) + range(87001, 87005) +
                                range(89001, 89003) + range(90001, 90019))


def ATKIS_to_OSM_way_tag_interpreter(key, val):
  ''' Interprets way tags of OSM files created by ogr2osm.py from ATKIS data.
  
  This data comes with a lot if tag lines of this format:
    <tag k="KEY" v="VAL" />
  We are only interested in ways which are streets, footpaths and so on. These
  have a tag with KEY="KLASSE" and VAL being an interger in a range according to
  the ATKIS documentation.
  Moreover, the speed on these streets is explicitly given by two tags with
  KEY="Speed_Tobl" and KEY="Speed_To_1" (forward and backward speed). We take
  the average of these two. 
  HACK: We just take one value, whichever comes last.
  HACKHACK: We don't care--and take a handish speed table.

  '''
  if key == 'KLASSE':
    if int(val) in atkis_speed_table:
      return type_to_speed(int(val), atkis_speed_table)
    else:
      print key, val
  return False


def great_circle_distance((lat0, lon0), (lat1, lon1)):
  ''' In meters, follows http://en.wikipedia.org/wiki/Great-circle_distance '''
  to_rad = math.pi / 180.
  r = 6371000.785
  dLat = (lat1 - lat0) * to_rad
  dLon = (lon1 - lon0) * to_rad
  a = math.sin(dLat / 2.) * math.sin(dLat / 2.)
  a += math.cos(lat0 * to_rad) * math.cos(lat1 * to_rad) * \
      math.sin(dLon / 2) * math.sin(dLon / 2)
  return 2 * r * math.asin(math.sqrt(a))


def read_file(filename, maxspeed, interpret=Std_OSM_way_tag_interpreter):
  ''' Parses nodes and arcs from an OSM file.
      Creates two mappings, a graph and a collection of nodes from an osm-file.
      - a mapping {way id -> [list of node ids]}
      - a mapping {way type -> [list of way ids]}
      - a bidirectional graph as a map {node_id -> set([successors])}
      - a dictionary of nodes {node_id -> (lon, lat)}
      - a mapping {osm id -> graph node index}
  '''
  def expand_way_to_edges(way_node_list):
    ''' For a list of way nodes, this adds arcs between successors.
    '''
    edges = []
    size = len(way_node_list)
    for i, j in zip(range(size-1), range(1,size)):
      edges.append((way_node_list[i], way_node_list[j]))
    return edges
  def calculate_edge_cost(a, b, v):
    s = great_circle_distance(a, b)
    t = s / (v * 1000. / 60**2)
    return t
  f = open(filename)
  p_node = re.compile('.*<node id="(\S+)" lat="(\S+)" lon="(\S+)"')
  nodes = {}
  p_waytag = re.compile('\D*k="(\w+)" v="(\w+)"')
  way_nodes = {}
  ways_by_type = {'forest_delim': [], 'highway': []}
  graph = Graph()
  osm_id_map = {}
  state = 'none'
  for line in f:
    stripped = line.strip()
    res = p_node.match(line)
    if res:
      assert state != 'way'
      # switch (lat, lon) to (lon, lat) for (x, y)-coordinates
      nodes[int(res.group(1))] = (float(res.group(3)), float(res.group(2)))
    elif state == 'none':
      if stripped.startswith('<way'):
        state = 'way'
        way_id = int(line.split('id=\"')[1].split('\"')[0])
        node_list = []
    if state == 'way':
      if stripped.startswith('<tag'):
        res = p_waytag.match(stripped)
        if res:
          key, val = res.group(1), res.group(2)
          res = interpret(key, val)
          if res:
            v = res
            ways_by_type['highway'].append(way_id)
          elif ((key == 'landuse' and val == 'forest') or  
                (key == 'natural' and val == 'wood')):
            ways_by_type['forest_delim'].append(way_id)
      elif stripped.startswith('<nd'):
        node_id = int(stripped.split("ref=\"")[1].split("\"")[0])
        node_list.append(node_id)
      elif stripped.startswith('</way'):
        state = 'none'
        if len(ways_by_type['highway']) \
            and ways_by_type['highway'][-1] is way_id:
          edges = expand_way_to_edges(node_list)
          # HACK for walking: do not allow to walk on fast roads (separate
          # pavement is assumed)
          v = 0 if maxspeed == 5 and v > 50 else v
          v = v if v <= maxspeed else maxspeed
          if v != 0:
            way_nodes[way_id] = node_list
            for e in edges:
              if e[0] not in osm_id_map:
                osm_id_map[e[0]] = len(graph.nodes)
              x = osm_id_map[e[0]]
              if e[1] not in osm_id_map:
                osm_id_map[e[1]] = len(graph.nodes)
              y = osm_id_map[e[1]]
              if x == y:
                y += 1
                osm_id_map[e[1]] = y
              t = calculate_edge_cost(nodes[e[0]], nodes[e[1]], v)
              graph.add_edge(x, y, t)
              graph.add_edge(y, x, t)
          else:  # v == 0
            ways_by_type['highway'].pop()
        elif len(ways_by_type['forest_delim']) \
            and ways_by_type['forest_delim'][-1] is way_id:
          way_nodes[way_id] = node_list
    elif stripped.startswith("<relation"):  # ignore relations
      break
  return way_nodes, ways_by_type, graph, nodes, osm_id_map



