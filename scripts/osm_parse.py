""" osm_parse.py

Usage information is located at the end of the document.

Contains code to parse data from standard OSM files (e.g. generated by
geofabrik) and from ATKIS data converted to OSM by ogr2osm.py.

Copyright 2013: Institut fuer Informatik
Author: Jonas Sternisko <sternis@informatik.uni-freiburg.de>

"""
import math
import re
import sys
from graph import Graph, Edge, NodeInfo

OSMWayTypesAndSpeed = [('motorway'       , 130),
                       ('motorway_link'  , 130),
                       ('trunk'          , 120),
                       ('trunk_link'     , 120),
                       ('primary'        , 120),
                       ('primary_link'   , 120),
                       ('secondary'      , 80),
                       ('secondary_link' , 80),
                       ('tertiary'       , 80),
                       ('tertiary_link'  , 70),
                       ('unclassified'   , 50),
                       ('road'           , 50),
                       ('residential'    , 45),
                       ('living_street'  , 30),
                       ('service'        , 30),
                       ('track'          , 30),
                       ('path'           , 5),
                       ('unsurfaced'     , 30),
                       ('cycleway'       , 25),
                       ('bridleway'      , 5),
                       ('OTHER'          , 0),
                       ('footway'        , 5),
                       ('pedestrian'     , 5),
                       ('steps'          , 3)]

OSMSpeedTable = dict(OSMWayTypesAndSpeed)
OSMWayTypeToId = {v[0] : id
                  for id, v in enumerate(OSMWayTypesAndSpeed)}

ATKISSpeedTable = {164001 : 110,
                   164003 : 70,
                   164005 : 110,
                   164007 : 70,
                   164009 : 110,
                   164010 : 70,
                    87001 : 50,
                    87003 : 5,
                    87004 : 25,
                    88001 : 25,
                    89001 : 25,
                    89002 : 10,
                    90001 : 110,
                    90003 : 70,
                    90005 : 110,
                    90007 : 70,
                    90009 : 110,
                    90010 : 70,
                    90012 : 50,
                    90014 : 5,
                    90015 : 25,
                    90016 : 25,
                    90017 : 25,
                    90018 : 10}

def type_to_speed(type, speed_table):
    if type in speed_table:
        return speed_table[type]
    else:
        print "type '" + type + "' unknown."
        return 0


def OSMWayTagInterpreter(key, val):
    """Interprets way tags of a standard OSM file.

    Such lines have a format
      <tag k="KEY" v="VAL" />
    We are interested only in ways of KEY=highway and with VAL being one of
    the way types declared in the speed table.

    """
    if key == 'highway' and val in OSMSpeedTable:
        return type_to_speed(val, OSMSpeedTable)
    return False


ATKIS_HIGHWAY_VALUE_RANGE = set(range(164001, 164012) + range(87001, 87005) +
                                range(89001, 89003) + range(90001, 90019))


def ATKISWayTagInterpreter(key, val):
    """Interprets way tags of OSM files created by ogr2osm.py from ATKIS data.

    This data comes with a lot if tag lines of this format:
      <tag k="KEY" v="VAL" />
    We are only interested in ways which are streets, footpaths and so on.
    These have a tag with KEY="KLASSE" and VAL being an interger in a range
    according to the ATKIS documentation.
    Moreover, the speed on these streets is explicitly given by two tags with
    KEY="Speed_Tobl" and KEY="Speed_To_1" (forward and backward speed). We take
    the average of these two.
    HACK: We just take one value, whichever comes last.
    HACKHACK: We don't care--and take a handish speed table.

    """
    if key == 'KLASSE':
        if int(val) in ATKISSpeedTable:
            return type_to_speed(int(val), ATKISSpeedTable)
        else:
            print "Unknown combination: ", key, val
    return False


def great_circle_distance((lat0, lon0), (lat1, lon1)):
    """In meters, after http://en.wikipedia.org/wiki/Great-circle_distance."""
    to_rad = math.pi / 180.
    r = 6371000.785
    dLat = (lat1 - lat0) * to_rad
    dLon = (lon1 - lon0) * to_rad
    a = math.sin(dLat / 2.) * math.sin(dLat / 2.)
    a += (math.cos(lat0 * to_rad) * math.cos(lat1 * to_rad) *
          math.sin(dLon / 2) * math.sin(dLon / 2))
    return 2 * r * math.asin(math.sqrt(a))

def is_forest_tag(key, val):
    """Returns true on key, value pairs which represent forest OSM tags."""
    return ((key == 'landuse' and val == 'forest') or
            (key == 'natural' and val == 'wood'))

class OSMRelation(object):
    """Right now, this represents a multipolygon.

    See http://wiki.openstreetmap.org/wiki/Relation:multipolygon

    """
    def __init__(self, id_):
        self.id_ = id_
        self.isForestRelation = False
        self.isMultipolygon = False
        self.outerOsmWays = []
        self.innerOsmWays = []

    def add_member(self, type_, ref, role):
        if type_ == "way":
            if role == "outer":
                self.outerOsmWays.append(ref)
            elif role == "inner":
                self.innerOsmWays.append(ref)
            else:
                print "Error: Unexpected role for relation member way: ", role

    def is_forest_relation(self, newValue):
        self.isForestRelation = newValue

    def is_multipolygon(self, newValue):
        self.isMultipolygon = newValue

    def is_forest_multipolygon(self):
        return self.isForestRelation and self.isMultipolygon

    def expand_to_polygons(self, ref_to_way, ref_to_node):
        """Expands the osm ways described by this relation to polygons.

        Takes two functions mapping from way ids to ways (lists of node
        references) and from node ids to nodes (pairs of lat, lon).
        Expands the multipolygon relation such that all ways in self.outer
        and self.inner form polygons.

        """
        outer = self.expand_ways_to_polygons(self.outerOsmWays, ref_to_way,
                                             ref_to_node)
        inner = self.expand_ways_to_polygons(self.innerOsmWays, ref_to_way,
                                             ref_to_node)
        return outer, inner

    def expand_ways_to_polygons(self, ways, ref_to_way, ref_to_node):
        """Expands a set of ways (lists of way references) to a polygon.

        If there is a gap between the last node of a way and the first node
        of the next way, a new polygon is started.

        """
        def extract_coords(node):
            return (node[0], node[1])
        resultPolygons = []
        polygon = []
        lastNodeRefOfLastWay = -1
        DEBUG = False
        TARGET_IS_PART = False
        for wayRef in ways:
            wayDescription = ref_to_way(wayRef)
            if wayRef == 207409779:
                print wayDescription
                print "length: ", len(ways)
                #print ways
                DEBUG = True
                TARGET_IS_PART = True
            if not wayDescription:
                continue
            (osmWayId, wayType, polyline) = wayDescription
            osmNodeIds = polyline

            assert len(osmNodeIds) > 1
            firstNodeRefOfThisWay = osmNodeIds[0]
            if firstNodeRefOfThisWay != lastNodeRefOfLastWay:
                if DEBUG and TARGET_IS_PART:
                    print polygon
                if len(polygon) > 2:  # artifacts at data set borders
                    resultPolygons.append(polygon)
                polygon = [extract_coords(ref_to_node(firstNodeRefOfThisWay))]
                TARGET_IS_PART = False
            for nodeRef in osmNodeIds[1:]:
                polygon.append(extract_coords(ref_to_node(nodeRef)))
            lastNodeRefOfLastWay = osmNodeIds[-1]
        if len(polygon) > 2:  # add last polygon, artifacts at data set borders
            resultPolygons.append(polygon)
        if DEBUG:
            print "========RESULT==========="
            #print resultPolygons
            print len(resultPolygons)
            exit(1)
        return resultPolygons


class OSMParser(object):
    def __init__(self, maxSpeed):
        self.maxSpeed = maxSpeed
        self.regexPatternNode = re.compile(
                '<node id="(\S+)".* lat="(\S+)" lon="(\S+)"')
        self.regexPatternWayStart = re.compile(
                '<way.* id="(\S+)".*')
        self.regexPatternWayTag = re.compile(
                '\D*k="(highway|landuse|natural)" v="(.+)"')
        self.regexPatternRelationMember = re.compile(
                '<member type="way" ref="(\S+)" role="(\S+)"/>')
        self.regexPatternRelationTag = re.compile(
                '<tag k="(type|landuse|natural)" v="(\S+)"/>')
        self.osmNodes = []
        self.osmHighwayEdges = []
        self.osmNodeIdPolygons = []
        self.osmIdToNodeIndex = None
        self.osmIdToArcIndex = None
        self.osmRelations = []
        self.lineNumber = 0
        self.currentWayType = 'undefined'

    def osm_id_to_node(self, osmId):
        return self.osmNodes[self.osm_id_to_node_index(osmId)]

    def osm_id_to_node_index(self, osmId):
        if not self.osmIdToNodeIndex:
            self.osmIdToNodeIndex = {osm : i
                                 for i, (_,_,osm) in enumerate(self.osmNodes)}
        return self.osmIdToNodeIndex[osmId]

    def osm_id_to_arc(self, osmId):
        if self.osmIdToArcIndex and osmId not in self.osmIdToArcIndex:
            # Some ways are referenced in relations but outside of the dataset.
            return None
        return self.osmNodeIdPolygons[self.osm_id_to_arc_index(osmId)]

    def osm_id_to_arc_index(self, osmId):
        if not self.osmIdToArcIndex:
            dic = {osmId_ : i
                   for i, (osmId_,_,_) in enumerate(self.osmNodeIdPolygons)}
            self.osmIdToArcIndex = dic
        return self.osmIdToArcIndex[osmId]

    def parse_node_properties(self, match):
        """Extracts latitude, longitude and osmID from a regex match object."""
        return (float(match.group(2)), float(match.group(3)),
                int(match.group(1)))

    def compute_dist_between_ids(self, osmIdA, osmIdB, wayClass):
        (latA, lonA, _) = self.osmNodes[self.osm_id_to_node_index(osmIdA)]
        (latB, lonB, _) = self.osmNodes[self.osm_id_to_node_index(osmIdB)]
        return great_circle_distance((latA, lonA), (latB, lonB))

    def compute_cost_between_ids(self, osmIdA, osmIdB, wayClass):
        s = self.compute_dist_between_ids(osmIdA, osmIdB, wayClass)
        v = type_to_speed(wayClass, OSMSpeedTable)
        v = v if v <= self.maxSpeed else self.maxSpeed
        t = s / (v / 3.6)
        return t

    def expand_current_way_to_edges(self, bidirectional=True):
        """Expands a list of way node ids to a sequence of edges."""
        wayNodeIdList = self.currentWay
        edges = []
        size = len(wayNodeIdList)
        for i, j in zip(range(size-1), range(1,size)):
            osmIdA = wayNodeIdList[i]
            osmIdB = wayNodeIdList[j]
            wayClass = self.currentHighwayCategory
            labels = [self.compute_dist_between_ids(osmIdA, osmIdB, wayClass),
                      self.compute_cost_between_ids(osmIdA, osmIdB, wayClass),
                      OSMWayTypeToId[wayClass]]
            edges.append((wayNodeIdList[i], wayNodeIdList[j], labels))
            if bidirectional:
                edges.append((wayNodeIdList[j], wayNodeIdList[i], labels))
        return edges

    def read_node_line(self, line, state):
        """Processes a line which denotes a node and returns a new state."""
        if state != 'read_nodes' and line.startswith('<node'):
            state = 'read_nodes'
        if state == 'read_nodes':
            res = self.regexPatternNode.match(line)
            if res:
                self.osmNodes.append(self.parse_node_properties(res))
                if not line.endswith('/>'):
                    state = 'node_content'
            else:
                if line.startswith("<way"):
                    state = 'read_ways'
                else:
                    print "Error: Got unexpected line in state 'read_nodes':"
                    print self.lineNumber, line
                    exit(1)

        return state

    def read_way_line(self, line, state):
        """Processes a line which describes a way and returns a new state."""
        if line.startswith("<way"):
            res = self.regexPatternWayStart.match(line)
            assert res
            self.currentWay = []
            self.currentWayType = 'undefined'
            self.currentHighwayCategory = None
            self.currentWayId = int(res.group(1))
        elif line.startswith("<nd"):
            osmId = int(line.split("ref=\"")[1].split("\"")[0])
            self.currentWay.append(osmId)
        elif line.startswith("<tag"):
            self.process_way_tag_line(line)
        elif line.startswith("</way"):
            self.finalize_way()
        elif line.startswith("<relation"):
            state = 'read_relations'
        else:
            pass
        return state

    def process_way_tag_line(self, line):
        """Processes an OSM way tag line."""
        res = self.regexPatternWayTag.match(line)
        if res:
            key, val = res.group(1), res.group(2)
            if key == 'highway' and val in OSMSpeedTable:
                self.currentWayType = 'highway'
                self.currentHighwayCategory = val
            elif is_forest_tag(key, val):
                self.currentWayType = 'forest_delimiter'

    def finalize_way(self):
        """Finishes the current way."""
        waytype = self.currentWayType
        # related store all ways, as they may serve as boundary in a relation
        polyline = self.currentWay
        osmId = self.currentWayId
        self.osmNodeIdPolygons.append((osmId, waytype, polyline))
        if waytype == 'highway':
            self.osmHighwayEdges.extend(self.expand_current_way_to_edges())

    def read_relation_line(self, line, state):
        """Processes a line associated with a relation."""
        if line.startswith("<relation"):
            id_ = int(line.split('"')[1])
            self.currentRelation = OSMRelation(id_)
        elif line.startswith("</relation"):
            self.finalize_relation(self.currentRelation)
            self.currentRelation = None
        elif line.startswith("</osm>"):
            state = 'other'
        else:
            self.process_multipolygon_relation_content_line(line)
        return state

    def process_multipolygon_relation_content_line(self, line):
        assert self.currentRelation
        res = self.regexPatternRelationMember.match(line)
        if res:
            ref = int(res.group(1))
            role = res.group(2)
            if role == "outer" or role == "inner":
                self.currentRelation.add_member("way", ref, role)
        else:
            res = self.regexPatternRelationTag.match(line)
            if res:
                if is_forest_tag(res.group(1), res.group(2)):
                    self.currentRelation.is_forest_relation(True)
                elif res.group(1) == "type" and res.group(2) == "multipolygon":
                    self.currentRelation.is_multipolygon(True)

    def finalize_relation(self, relation):
        assert relation
        #if not (not relation.isForestRelation or relation.isMultipolygon):
        #    print "Error: forest relation is no multipolygon. In line", self.lineNumber
        #    print relation.isForestRelation, relation.isMultipolygon
        #    assert False
        #if relation.is_forest_multipolygon():  # removed. reason: data errors
        if relation.isForestRelation:
            self.osmRelations.append(relation)

    def expand_relations(self):
        """Expands relations. Should be called after all relations are read."""
        self.outerForestPolygons = []
        self.innerForestPolygons = []
        self.osmIdToArcIndex = None
        for relation in self.osmRelations:
            outer, inner = relation.expand_to_polygons(self.osm_id_to_arc,
                                                       self.osm_id_to_node)
            self.outerForestPolygons.extend(outer)
            self.innerForestPolygons.extend(inner)

    def read_line(self, line, state):
        """Reads and interprets a line."""
        if state == 'read_nodes' or state == 'init' or state == 'node_content':
            state = self.read_node_line(line, state)
        if state == 'read_ways':
            state = self.read_way_line(line, state)
        if state == 'read_relations':
            state = self.read_relation_line(line, state)
        return state

    def read_osm_file(self, filename):
        """Reads an Open Street Map file.

        Returns nodes, edges, forest polygons:
          - Nodes are tuples (lat, lon, osmID).
          - Edges are between two nodes, referred to by indices [0...#nodes-1].
          - Forest polygons, each is a list of tuples (lat, lon, osmID).
          - Inner forest polygons (glades), as above.

        Assumes that the OSM file is ordered such that it lists nodes before
        ways and ways before anything else.
        Assumes that ways list node references first and tags afterwards.

        """
        state = 'init'
        with open(filename) as f:
            for line in f:
                self.lineNumber += 1
                state = self.read_line(line.strip(), state)
                if state == 'other':
                    break

        nodes = self.highway_part(self.osmNodes, self.osmHighwayEdges)
        edges = self.translate_osm_edges(nodes, self.osmHighwayEdges)

        if 112835 in set([rel.id_ for rel in self.osmRelations]):
            print "relation contained"
        else:
            print "relation not contained"

        self.expand_relations()  # translates relations into node polygons
        enum = enumerate(self.osmNodeIdPolygons)
        nodeIdPolygons = [poly for i, (osmId, wayType, poly) in enum
                          if wayType == 'forest_delimiter']
        # TODO(jonas): Avoid double usage of forest borders in from relations.
        simplePolygons = self.translate_osm_to_node_polygons(nodeIdPolygons)
        outerPolygons = self.outerForestPolygons + simplePolygons
        innerPolygons = self.innerForestPolygons
        return nodes, edges, outerPolygons, innerPolygons

    def highway_part(self, osmNodes, osmHighwayEdges):
        """Returns the nodes which are part of a highway in the OSM data."""
        isHighwayNode = [False] * len(osmNodes)
        for (s, t, _) in osmHighwayEdges:
            isHighwayNode[self.osm_id_to_node_index(s)] = True
            isHighwayNode[self.osm_id_to_node_index(t)] = True
        return [node for i, node in enumerate(osmNodes) if isHighwayNode[i]]

    def translate_osm_edges(self, highwayNodes, osmHighwayEdges):
        """Replaces osm node ids in edges with corresponding node indices."""
        mapping = {osm : index for index, (_,_,osm) in enumerate(highwayNodes)}
        return [(mapping[s], mapping[t], label)
                for (s, t, label) in osmHighwayEdges]

    def translate_osm_to_node_polygons(self, osmNodeIdPolygons):
        """Replaces osm node ids with coordinates."""
        tmp = [map(self.osm_id_to_node, poly) for poly in osmNodeIdPolygons]
        return [[(lat,lon) for lat,lon,_ in poly] for poly in tmp]



def read_file(filename, maxspeed, interpret=OSMWayTagInterpreter):
    """Parses nodes and arcs from an OSM file.

    Creates two mappings, a graph and a collection of nodes from an osm-file.
    - a mapping {way id -> [list of node ids]}
    - a mapping {way type -> [list of way ids]}
    - a bidirectional graph as a map {node_id -> set([successors])}
    - a dictionary of nodes {node_id -> (lon, lat)}
    - a mapping {osm id -> graph node index}

    """
    def expand_way_to_edges(way_node_list):
        """For a list of way nodes, this adds arcs between successors."""
        edges = []
        size = len(way_node_list)
        for i, j in zip(range(size-1), range(1,size)):
            edges.append((way_node_list[i], way_node_list[j]))
        return edges
    def calculate_edge_cost(a, b, v):
        s = great_circle_distance(a, b)
        t = s / (v / 3.6)
        return t
    f = open(filename)
    regexPatternNode = re.compile('.*<node id="(\S+)" lat="(\S+)" lon="(\S+)"')
    nodes = {}
    regexPatternWaytag = re.compile('\D*k="(\w+)" v="(\w+)"')
    way_nodes = {}
    ways_by_type = {'forest_delim': [], 'highway': []}
    graph = Graph()
    osm_id_map = {}
    state = 'none'
    for line in f:
        stripped = line.strip()
        res = regexPatternNode.match(line)
        if res:
            assert state != 'way'
            # switch (lat, lon) to (lon, lat) for (x, y)-coordinates
            nodes[int(res.group(1))] = (float(res.group(3)), float(res.group(2)))
        elif state == 'none':
            if stripped.startswith('<way'):
                state = 'way'
                way_id = int(line.split('id=\"')[1].split('\"')[0])
                node_list = []
        if state == 'way':
            if stripped.startswith('<tag'):
                res = regexPatternWaytag.match(stripped)
                if res:
                    key, val = res.group(1), res.group(2)
                    res = interpret(key, val)
                    if res:
                        v = res
                        ways_by_type['highway'].append(way_id)
                    elif ((key == 'landuse' and val == 'forest') or
                          (key == 'natural' and val == 'wood')):
                        ways_by_type['forest_delim'].append(way_id)
            elif stripped.startswith('<nd'):
                node_id = int(stripped.split("ref=\"")[1].split("\"")[0])
                node_list.append(node_id)
            elif stripped.startswith('</way'):
                state = 'none'
                if (len(ways_by_type['highway']) and
                        ways_by_type['highway'][-1] is way_id):
                    edges = expand_way_to_edges(node_list)
                    # HACK for walking: do not allow to walk on fast roads
                    # (assumes separate pavement exists in data)
                    v = 0 if maxspeed == 5 and v > 50 else v
                    v = v if v <= maxspeed else maxspeed
                    if v != 0:
                        way_nodes[way_id] = node_list
                        for e in edges:
                            if e[0] not in osm_id_map:
                                osm_id_map[e[0]] = len(graph.nodes)
                            x = osm_id_map[e[0]]
                            if e[1] not in osm_id_map:
                                osm_id_map[e[1]] = len(graph.nodes)
                            y = osm_id_map[e[1]]
                            if x == y:
                                y += 1
                                osm_id_map[e[1]] = y
                            n1, n2 = nodes[e[0]], nodes[e[1]]
                            t = calculate_edge_cost(n1, n2, v)
                            graph.add_edge(x, y, t)
                            graph.add_edge(y, x, t)
                    else:  # v == 0
                        ways_by_type['highway'].pop()
                elif (len(ways_by_type['forest_delim']) and
                        ways_by_type['forest_delim'][-1] is way_id):
                    way_nodes[way_id] = node_list
        elif stripped.startswith("<relation"):  # ignore relations
            break
    return way_nodes, ways_by_type, graph, nodes, osm_id_map


def dump_graph(nodes, edges, filename=None, nodeFlags=None):
    from itertools import izip
    """Writes output to some target, stdout by default."""
    if filename:
        with open(filename + ".graph.txt", "w") as f:
            f.write(str(len(nodes)) + "\n")
            f.write(str(len(edges)) + "\n")
            if not nodeFlags:
                for node in nodes:
                    (lat, lon, osm_id) = node
                    f.write("{0} {1} {2}\n".format(lat, lon, osm_id))
            else:
                for node, flag in izip(nodes, nodeFlags):
                    (lat, lon, osm_id) = node
                    f.write("{0} {1} {2} {3}\n".format(lat, lon, osm_id, flag))
            for edge in edges:
                s, t, labels = edge
                labelsAsString = " ".join([str(l) for l in labels])
                f.write("{0} {1} {2}\n".format(s, t, labelsAsString))
    else:
        print len(nodes)
        print len(edges)
        for node in nodes:
            (lat, lon, osm_id) = node
            print lat, lon#, osm_id
        for edge in edges:
            s, t, labels = edge
            labelsAsString = " ".join([str(l) for l in labels])
            print "{0} {1} {2}\n".format(s, t, labelsAsString)

def dump_json(nodes, edges, filename="dummy.json"):
    def format_json_datapoint(lat, lon, count):
        s = """{{"lat": {0}, "lon": {1}, "count": {2}}}""".format(lat, lon, count)
        return s
    with open(filename, "w") as f:
        dataPoints = []
        max_ = 0.
        for (s, t, labels) in edges:
            dist, time, waytype = labels
            count = float(dist)
            max_ = max(max_, count)
            for nodeIndex in [s, t]:
                lat = nodes[nodeIndex][0]
                lon = nodes[nodeIndex][1]
                dataPoints.append(format_json_datapoint(lat, lon, count))
        f.write('{')
        f.write('"max": ' + str(max_) + ',')
        f.write('"data": [{0}]'.format(", ".join(dataPoints)))
        f.write('}')

def main():
    """Reads an osm file and dumps the resulting nodes, arcs and polygons."""
    if len(sys.argv) < 2:
        sys.stderr.write("Usage: ./script.py <osm_file>")
        exit(1)
    parser = OSMParser(maxSpeed=50)
    nodes, edges, forest, glades = parser.read_osm_file(sys.argv[1])
    #dump_graph(nodes, edges)
    #dump_json(nodes, edges)
    import pickle
    with open("nodes.pickle", "w") as f:
        pickle.dump(nodes, f)
    with open("edges.pickle", "w") as f:
        pickle.dump(edges, f)


if __name__ == '__main__':
    main()

