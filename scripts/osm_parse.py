""" osm_parse.py

Usage information is located at the end of the document.

Contains code to parse data from standard OSM files (e.g. generated by
geofabrik) and from ATKIS data converted to OSM by ogr2osm.py.

Copyright 2013: Institut fuer Informatik
Author: Jonas Sternisko <sternis@informatik.uni-freiburg.de>

"""
import math
import re
import sys
from graph import Graph, Edge, NodeInfo


OSMWayTypesAndSpeed = [('motorway'       , 130),
                       ('motorway_link'  , 130),
                       ('trunk'          , 120),
                       ('trunk_link'     , 120),
                       ('primary'        , 120),
                       ('primary_link'   , 120),
                       ('secondary'      , 80),
                       ('secondary_link' , 80),
                       ('tertiary'       , 80),
                       ('tertiary_link'  , 70),
                       ('unclassified'   , 50),
                       ('road'           , 50),
                       ('residential'    , 45),
                       ('living_street'  , 30),
                       ('service'        , 30),
                       ('track'          , 30),
                       ('path'           , 5),
                       ('unsurfaced'     , 30),
                       ('cycleway'       , 25),
                       ('bridleway'      , 5),
                       ('OTHER'          , 0),
                       ('footway'        , 5),
                       ('pedestrian'     , 5),
                       ('steps'          , 3)]

OSMSpeedTable = dict(OSMWayTypesAndSpeed)
OSMWayTypeToId = {v[0] : id
                  for id, v in enumerate(reversed(OSMWayTypesAndSpeed))}

ATKISSpeedTable = {164001 : 110,
                   164003 : 70,
                   164005 : 110,
                   164007 : 70,
                   164009 : 110,
                   164010 : 70,
                    87001 : 50,
                    87003 : 5,
                    87004 : 25,
                    88001 : 25,
                    89001 : 25,
                    89002 : 10,
                    90001 : 110,
                    90003 : 70,
                    90005 : 110,
                    90007 : 70,
                    90009 : 110,
                    90010 : 70,
                    90012 : 50,
                    90014 : 5,
                    90015 : 25,
                    90016 : 25,
                    90017 : 25,
                    90018 : 10}

def type_to_speed(type, speed_table):
    if type in speed_table:
        return speed_table[type]
    else:
        print "type '" + type + "' unknown."
        return 0


def OSMWayTagInterpreter(key, val):
    """Interprets way tags of a standard OSM file.

    Such lines have a format
      <tag k="KEY" v="VAL" />
    We are interested only in ways of KEY=highway and with VAL being one of
    the way types declared in the speed table.

    """
    if key == 'highway' and val in OSMSpeedTable:
        return type_to_speed(val, OSMSpeedTable)
    return False


ATKIS_HIGHWAY_VALUE_RANGE = set(range(164001, 164012) + range(87001, 87005) +
                                range(89001, 89003) + range(90001, 90019))


def ATKISWayTagInterpreter(key, val):
    """Interprets way tags of OSM files created by ogr2osm.py from ATKIS data.

    This data comes with a lot if tag lines of this format:
      <tag k="KEY" v="VAL" />
    We are only interested in ways which are streets, footpaths and so on.
    These have a tag with KEY="KLASSE" and VAL being an interger in a range
    according to the ATKIS documentation.
    Moreover, the speed on these streets is explicitly given by two tags with
    KEY="Speed_Tobl" and KEY="Speed_To_1" (forward and backward speed). We take
    the average of these two.
    HACK: We just take one value, whichever comes last.
    HACKHACK: We don't care--and take a handish speed table.

    """
    if key == 'KLASSE':
        if int(val) in ATKISSpeedTable:
            return type_to_speed(int(val), ATKISSpeedTable)
        else:
            print "Unknown combination: ", key, val
    return False


def great_circle_distance((lat0, lon0), (lat1, lon1)):
    """In meters, after http://en.wikipedia.org/wiki/Great-circle_distance."""
    to_rad = math.pi / 180.
    r = 6371000.785
    dLat = (lat1 - lat0) * to_rad
    dLon = (lon1 - lon0) * to_rad
    a = math.sin(dLat / 2.) * math.sin(dLat / 2.)
    a += (math.cos(lat0 * to_rad) * math.cos(lat1 * to_rad) *
          math.sin(dLon / 2) * math.sin(dLon / 2))
    return 2 * r * math.asin(math.sqrt(a))


class OSMParser(object):
    def __init__(self, maxSpeed):
        self.maxSpeed = maxSpeed
        self.regexPatternNode = re.compile(
                '.*<node id="(\S+)" lat="(\S+)" lon="(\S+)"')
        self.regexPatterWaytag = re.compile(
                '\D*k="(highway|landuse|natural)" v="(.+)"')
        self.osmNodes = []
        self.osmHighwayEdges = []
        self.osmNodeIdPolygons = []
        self.osmIdToIndex = None
        self.lineNumber = 0

    def parse_node_properties(self, match):
        """Extracts latitude, longitude and osmID from a regex match object."""
        return (float(match.group(2)), float(match.group(3)),
                int(match.group(1)))

    def compute_dist_between_ids(self, osmIdA, osmIdB, wayClass):
        (latA, lonA, _) = self.osmNodes[self.osm_id_to_index(osmIdA)]
        (latB, lonB, _) = self.osmNodes[self.osm_id_to_index(osmIdB)]
        return great_circle_distance((latA, lonA), (latB, lonB))

    def compute_cost_between_ids(self, osmIdA, osmIdB, wayClass):
        s = self.compute_dist_between_ids(osmIdA, osmIdB, wayClass)
        v = type_to_speed(wayClass, OSMSpeedTable)
        v = v if v <= self.maxSpeed else self.maxSpeed
        t = s / (v / 3.6)
        return t

    def expand_current_way_to_edges(self, bidirectional=True):
        """Expands a list of way node ids to a sequence of edges."""
        wayNodeIdList = self.currentWay
        edges = []
        size = len(wayNodeIdList)
        for i, j in zip(range(size-1), range(1,size)):
            osmIdA = wayNodeIdList[i]
            osmIdB = wayNodeIdList[j]
            wayClass = self.currentHighwayCategory
            labels = [self.compute_dist_between_ids(osmIdA, osmIdB, wayClass),
                      self.compute_cost_between_ids(osmIdA, osmIdB, wayClass),
                      OSMWayTypeToId[wayClass]]
            edges.append((wayNodeIdList[i], wayNodeIdList[j], labels))
            if bidirectional:
                edges.append((wayNodeIdList[j], wayNodeIdList[i], labels))
        return edges

    def read_node_line(self, line, state):
        """Processes a line which denotes a node and returns a new state."""
        if state != 'read_nodes' and line.startswith('<node'):
            state = 'read_nodes'
        if state == 'read_nodes':
            res = self.regexPatternNode.match(line)
            if res:
                self.osmNodes.append(self.parse_node_properties(res))
                if not line.endswith('/>'):
                    state = 'node_content'
            else:
                if line.startswith("<way"):
                    state = 'read_ways'
                else:
                    print "Error: Got unexpected line in state 'read_nodes':"
                    print self.lineNumber, line
                    exit(1)

        return state

    def read_way_line(self, line, state):
        """Processes a line which describes a way and returns a new state."""
        if line.startswith("<way"):
            self.currentWay = []
            self.currentWayType = None
            self.currentHighwayCategory = None
        elif line.startswith("<nd"):
            osmId = int(line.split("ref=\"")[1].split("\"")[0])
            self.currentWay.append(osmId)
        elif line.startswith("<tag"):
            self.process_way_tag_line(line)
        elif line.startswith("</way"):
            self.finalize_way()
        elif line.startswith("<relation"):
            state = 'other'
        else:
            pass
        return state

    def process_way_tag_line(self, line):
        """Processes an OSM way tag line."""
        def is_forest_tag(key, val):
            return ((key == 'landuse' and val == 'forest') or
                    (key == 'natural' and val == 'wood'))
        res = self.regexPatterWaytag.match(line)
        if res:
            key, val = res.group(1), res.group(2)
            if key == 'highway' and val in OSMSpeedTable:
                self.currentWayType = 'highway'
                self.currentHighwayCategory = val
            elif is_forest_tag(key, val):
                self.currentWayType = 'forest_delimiter'

    def finalize_way(self):
        """Finishes the current way."""
        if self.currentWayType == 'forest_delimiter':
            polygon = self.currentWay
            self.osmNodeIdPolygons.append(polygon)
        elif self.currentWayType == 'highway':
            self.osmHighwayEdges.extend(self.expand_current_way_to_edges())
        else:
            # Undefined osm way, like soccer stadium, pool etc.
            pass

    def read_line(self, line, state):
        """Reads and interprets a line."""
        if state == 'read_nodes' or state == 'init' or state == 'node_content':
            state = self.read_node_line(line, state)
        if state == 'read_ways':
            state = self.read_way_line(line, state)
        return state

    def read_osm_file(self, filename):
        """Reads an Open Street Map file.

        Returns nodes, edges, forest polygons:
          - Nodes are tuples (lat, lon, osmID).
          - Edges are between two nodes, referred to by indices [0...#nodes-1].
          - Forest polygons each are a list of tuples (lat, lon, osmID).

        Assumes that the OSM file is ordered such that it lists nodes before
        ways and ways before anything else.
        Assumes that ways list node references first and tags afterwards.

        """
        state = 'init'
        with open(filename) as f:
            for line in f:
                self.lineNumber += 1
                state = self.read_line(line.strip(), state)
                if state == 'other':
                    break
        polys = self.translate_osm_to_node_polygons(self.osmNodeIdPolygons)
        nodes = self.highway_part(self.osmNodes, self.osmHighwayEdges)
        edges = self.translate_osm_edges(nodes, self.osmHighwayEdges)
        return nodes, edges, polys

    def highway_part(self, osmNodes, osmHighwayEdges):
        """Returns the nodes which are part of a highway in the OSM data."""
        isHighwayNode = [False] * len(osmNodes)
        for (s, t, _) in osmHighwayEdges:
            isHighwayNode[self.osm_id_to_index(s)] = True
            isHighwayNode[self.osm_id_to_index(t)] = True
        return [node for i, node in enumerate(osmNodes) if isHighwayNode[i]]

    def osm_id_to_node(self, osmId):
        return self.osmNodes[self.osm_id_to_index(osmId)]

    def osm_id_to_index(self, osmId):
        if not self.osmIdToIndex:
            self.osmIdToIndex = {osm : i
                                 for i, (_,_,osm) in enumerate(self.osmNodes)}
        return self.osmIdToIndex[osmId]

    def translate_osm_edges(self, highwayNodes, osmHighwayEdges):
        """Replaces osm node ids in edges with corresponding node indices."""
        mapping = {osm : index for index, (_,_,osm) in enumerate(highwayNodes)}
        return [(mapping[s], mapping[t], label)
                for (s, t, label) in osmHighwayEdges]

    def translate_osm_to_node_polygons(self, osmNodeIdPolygons):
        """Replaces osm node ids with coordinates."""
        tmp = [map(self.osm_id_to_node, poly) for poly in osmNodeIdPolygons]
        return [[(lat,lon) for lat,lon,_ in poly] for poly in tmp]  # strip osmId



def read_file(filename, maxspeed, interpret=OSMWayTagInterpreter):
    """Parses nodes and arcs from an OSM file.

    Creates two mappings, a graph and a collection of nodes from an osm-file.
    - a mapping {way id -> [list of node ids]}
    - a mapping {way type -> [list of way ids]}
    - a bidirectional graph as a map {node_id -> set([successors])}
    - a dictionary of nodes {node_id -> (lon, lat)}
    - a mapping {osm id -> graph node index}

    """
    def expand_way_to_edges(way_node_list):
        """For a list of way nodes, this adds arcs between successors."""
        edges = []
        size = len(way_node_list)
        for i, j in zip(range(size-1), range(1,size)):
            edges.append((way_node_list[i], way_node_list[j]))
        return edges
    def calculate_edge_cost(a, b, v):
        s = great_circle_distance(a, b)
        t = s / (v / 3.6)
        return t
    f = open(filename)
    regexPatternNode = re.compile('.*<node id="(\S+)" lat="(\S+)" lon="(\S+)"')
    nodes = {}
    regexPatterWaytag = re.compile('\D*k="(\w+)" v="(\w+)"')
    way_nodes = {}
    ways_by_type = {'forest_delim': [], 'highway': []}
    graph = Graph()
    osm_id_map = {}
    state = 'none'
    for line in f:
        stripped = line.strip()
        res = regexPatternNode.match(line)
        if res:
            assert state != 'way'
            # switch (lat, lon) to (lon, lat) for (x, y)-coordinates
            nodes[int(res.group(1))] = (float(res.group(3)), float(res.group(2)))
        elif state == 'none':
            if stripped.startswith('<way'):
                state = 'way'
                way_id = int(line.split('id=\"')[1].split('\"')[0])
                node_list = []
        if state == 'way':
            if stripped.startswith('<tag'):
                res = regexPatterWaytag.match(stripped)
                if res:
                    key, val = res.group(1), res.group(2)
                    res = interpret(key, val)
                    if res:
                        v = res
                        ways_by_type['highway'].append(way_id)
                    elif ((key == 'landuse' and val == 'forest') or
                          (key == 'natural' and val == 'wood')):
                        ways_by_type['forest_delim'].append(way_id)
            elif stripped.startswith('<nd'):
                node_id = int(stripped.split("ref=\"")[1].split("\"")[0])
                node_list.append(node_id)
            elif stripped.startswith('</way'):
                state = 'none'
                if (len(ways_by_type['highway']) and
                        ways_by_type['highway'][-1] is way_id):
                    edges = expand_way_to_edges(node_list)
                    # HACK for walking: do not allow to walk on fast roads
                    # (assumes separate pavement exists in data)
                    v = 0 if maxspeed == 5 and v > 50 else v
                    v = v if v <= maxspeed else maxspeed
                    if v != 0:
                        way_nodes[way_id] = node_list
                        for e in edges:
                            if e[0] not in osm_id_map:
                                osm_id_map[e[0]] = len(graph.nodes)
                            x = osm_id_map[e[0]]
                            if e[1] not in osm_id_map:
                                osm_id_map[e[1]] = len(graph.nodes)
                            y = osm_id_map[e[1]]
                            if x == y:
                                y += 1
                                osm_id_map[e[1]] = y
                            n1, n2 = nodes[e[0]], nodes[e[1]]
                            t = calculate_edge_cost(n1, n2, v)
                            graph.add_edge(x, y, t)
                            graph.add_edge(y, x, t)
                    else:  # v == 0
                        ways_by_type['highway'].pop()
                elif (len(ways_by_type['forest_delim']) and
                        ways_by_type['forest_delim'][-1] is way_id):
                    way_nodes[way_id] = node_list
        elif stripped.startswith("<relation"):  # ignore relations
            break
    return way_nodes, ways_by_type, graph, nodes, osm_id_map


def dump_graph(nodes, edges, filename=None, nodeFlags=None):
    from itertools import izip
    """Writes output to some target, stdout by default."""
    if filename:
        with open(filename + ".graph.txt", "w") as f:
            f.write(str(len(nodes)) + "\n")
            f.write(str(len(edges)) + "\n")
            if not nodeFlags:
                for node in nodes:
                    (lat, lon, osm_id) = node
                    f.write("{0} {1} {2}\n".format(lat, lon, osm_id))
            else:
                for node, flag in izip(nodes, nodeFlags):
                    (lat, lon, osm_id) = node
                    f.write("{0} {1} {2} {3}\n".format(lat, lon, osm_id, flag))
            for edge in edges:
                s, t, labels = edge
                labelsAsString = " ".join([str(l) for l in labels])
                f.write("{0} {1} {2}\n".format(s, t, labelsAsString))
    else:
        print len(nodes)
        print len(edges)
        for node in nodes:
            (lat, lon, osm_id) = node
            print lat, lon#, osm_id
        for edge in edges:
            s, t, labels = edge
            labelsAsString = " ".join([str(l) for l in labels])
            print "{0} {1} {2}\n".format(s, t, labelsAsString)


def main():
    """Reads an osm file and dumps the resulting nodes, arcs and polygons."""
    if len(sys.argv) < 2:
        sys.stderr.write("Usage: ./script.py <osm_file>")
        exit(1)
    parser = OSMParser(maxSpeed=50)
    nodes, edges, polygons = parser.read_osm_file(sys.argv[1])
    dump_graph(nodes, edges)
    print polygons


if __name__ == '__main__':
    main()

