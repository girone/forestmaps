""" osm_parse.py -- Parses OSM files and creates data for entities.

Usage information is located at the end of the document.

Contains code to parse data from standard OSM files (e.g. generated by
geofabrik) and from ATKIS data converted to OSM by ogr2osm.py.

Copyright 2013: Institut fuer Informatik
Author: Jonas Sternisko <sternis@informatik.uni-freiburg.de>

#TODO(jonas): Handle inner polygons in administrative boundaries. For example
              in "GVV St. Peter", osm way id 204934399.

"""
import sys
import osm_parse

# Deprecated method.
#def read_file(filename, maxspeed, interpret=OSMWayTagInterpreter):
    #"""Parses nodes and arcs from an OSM file.

    #Creates two mappings, a graph and a collection of nodes from an osm-file.
    #- a mapping {way id -> [list of node ids]}
    #- a mapping {way type -> [list of way ids]}
    #- a bidirectional graph as a map {node_id -> set([successors])}
    #- a dictionary of nodes {node_id -> (lon, lat)}
    #- a mapping {osm id -> graph node index}

    #"""
    #def expand_way_to_edges(way_node_list):
        #"""For a list of way nodes, this adds arcs between successors."""
        #edges = []
        #size = len(way_node_list)
        #for i, j in zip(range(size-1), range(1,size)):
            #edges.append((way_node_list[i], way_node_list[j]))
        #return edges
    #def calculate_edge_cost(a, b, v):
        #s = great_circle_distance(a, b)
        #t = s / (v / 3.6)
        #return t
    #f = open(filename)
    #regexPatternNode = re.compile('.*<node id="(\S+)" lat="(\S+)" lon="(\S+)"')
    #nodes = {}
    #regexPatternWaytag = re.compile('\D*k="(\w+)" v="(\w+)"')
    #way_nodes = {}
    #ways_by_type = {'forest_delim': [], 'highway': []}
    #graph = Graph()
    #osm_id_map = {}
    #state = 'none'
    #for line in f:
        #stripped = line.strip()
        #res = regexPatternNode.match(line)
        #if res:
            #assert state != 'way'
            ## switch (lat, lon) to (lon, lat) for (x, y)-coordinates
            #nodes[int(res.group(1))] = (float(res.group(3)), float(res.group(2)))
        #elif state == 'none':
            #if stripped.startswith('<way'):
                #state = 'way'
                #way_id = int(line.split('id=\"')[1].split('\"')[0])
                #node_list = []
        #if state == 'way':
            #if stripped.startswith('<tag'):
                #res = regexPatternWaytag.match(stripped)
                #if res:
                    #key, val = res.group(1), res.group(2)
                    #res = interpret(key, val)
                    #if res:
                        #v = res
                        #ways_by_type['highway'].append(way_id)
                    #elif ((key == 'landuse' and val == 'forest') or
                          #(key == 'natural' and val == 'wood')):
                        #ways_by_type['forest_delim'].append(way_id)
            #elif stripped.startswith('<nd'):
                #node_id = int(stripped.split("ref=\"")[1].split("\"")[0])
                #node_list.append(node_id)
            #elif stripped.startswith('</way'):
                #state = 'none'
                #if (len(ways_by_type['highway']) and
                        #ways_by_type['highway'][-1] is way_id):
                    #edges = expand_way_to_edges(node_list)
                    ## HACK for walking: do not allow to walk on fast roads
                    ## (assumes separate pavement exists in data)
                    #v = 0 if maxspeed == 5 and v > 50 else v
                    #v = v if v <= maxspeed else maxspeed
                    #if v != 0:
                        #way_nodes[way_id] = node_list
                        #for e in edges:
                            #if e[0] not in osm_id_map:
                                #osm_id_map[e[0]] = len(graph.nodes)
                            #x = osm_id_map[e[0]]
                            #if e[1] not in osm_id_map:
                                #osm_id_map[e[1]] = len(graph.nodes)
                            #y = osm_id_map[e[1]]
                            #if x == y:
                                #y += 1
                                #osm_id_map[e[1]] = y
                            #n1, n2 = nodes[e[0]], nodes[e[1]]
                            #t = calculate_edge_cost(n1, n2, v)
                            #graph.add_edge(x, y, t)
                            #graph.add_edge(y, x, t)
                    #else:  # v == 0
                        #ways_by_type['highway'].pop()
                #elif (len(ways_by_type['forest_delim']) and
                        #ways_by_type['forest_delim'][-1] is way_id):
                    #way_nodes[way_id] = node_list
        #elif stripped.startswith("<relation"):  # ignore relations
            #break
    #return way_nodes, ways_by_type, graph, nodes, osm_id_map


def dump_json(nodes, edges, filename="dummy.json"):
    def format_json_datapoint(lat, lon, count):
        s = """{{"lat": {0}, "lon": {1}, "count": {2}}}""".format(lat, lon, count)
        return s
    with open(filename, "w") as f:
        dataPoints = []
        max_ = 0.
        for (s, t, labels) in edges:
            dist, time, waytype = labels
            count = float(dist)
            max_ = max(max_, count)
            for nodeIndex in [s, t]:
                lat = nodes[nodeIndex][0]
                lon = nodes[nodeIndex][1]
                dataPoints.append(format_json_datapoint(lat, lon, count))
        f.write('{')
        f.write('"max": ' + str(max_) + ',')
        f.write('"data": [{0}]'.format(", ".join(dataPoints)))
        f.write('}')


def dump_communities(towns, fileprefix=None):
    """Formats and dumps output for communities in .info and .shape files."""
    def format_wiki_link(target):
        lang, article = target.split(":")
        article = article.replace(" ", "_")
        return "http://" + lang + ".wikipedia.org/wiki/" + article
    def format_osm_link(id_):
        return "http://www.openstreetmap.org/browse/relation/" + str(id_)

    # Group by key 'admin_level'
    communitiesByLevel = defaultdict(list)
    for town in towns:
        (tags, shape) = town
        communitiesByLevel[tags['admin_level']].append(town)

    if fileprefix:
        fileprefix += "_communities"
    else:
        fileprefix = "communities"

    for level, communities in communitiesByLevel.items():
        base = fileprefix + "_level_" + level
        with open(base + ".shape.txt", "w") as shapefile, \
             open(base + ".info.txt", "w") as infofile:
            for (tags, shape) in communities:
                shapefile.write("{0}\n".format(shape))
                infofile.write("{0}, {1}, {2}, {3}\n".format(
                        len(shape),
                        tags['name'],
                        (format_wiki_link(tags['wikipedia'])
                                if 'wikipedia' in tags else None),
                        format_osm_link(tags['id'])))


def main():
    """Reads an osm file and dumps the resulting nodes, arcs and polygons."""
    if len(sys.argv) < 2:
        print "Usage: ./script.py <osm_file>"
        exit(1)
    parser = osm_parse.OSMParser(maxSpeed=50)
    nodes, edges, (forest, glades), towns, pois = parser.read_osm_file(sys.argv[1])

    osm_parse.dump_graph(nodes, edges, filename="output")
    osm_parse.dump_pois(pois)

    #dump_json(nodes, edges)

    #import pickle
    #with open("nodes.pickle", "w") as f:
        #pickle.dump(nodes, f)
    #with open("edges.pickle", "w") as f:
        #pickle.dump(edges, f)

    #dump_communities(towns)


if __name__ == '__main__':
    main()

